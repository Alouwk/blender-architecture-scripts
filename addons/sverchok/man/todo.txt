ТУДУшечка.
дополняется снизу.

Сделать батарейки:
    5. выборка из списка по маске индексов:
        вход список
        вводное поле перечисленных индексов, берём конечный уровень - вершины, рёбра или полигоны или матрицы, целиком.
        выход список
        
    6. удаление элементов по индексу:
        вход список
        вводное поле перечисленных индексов, конечный уровень
        выход список
        
    9. вьюверу добавить галочку "показывать полигоны как прозрачные"
    
    11. сортировка списка:
        вход список
        галочка сортировка по значению А-Я и наоборот
        галочка сортировка по длине подсписка вершин/рёбер/полигонов
        выход список
    
    14. создатель рёбер:
        вход список вершин возможно с подуровнями
        галочка поперёк или вдоль
        выход список рёбер
	срочно доделать!!!!!!!!!!!!!!!
        
    15. создатель полигонов:
        вход список вершин
        вход список рёбер
        вход список маска по индексам рёбер. если нет, используется последовательное соединение
        выход список рёбер
    
    25. вьювер текст повесить обновление узла при нажатии кнопки, чтобы что?... ну ладно, повешу.
    
    надо думать 28. думаю, при желании можно организовать обновление адона автоматически. то есть кнопка - проверить обновление и если есть обновление, оно пишет что есть новая версия, появляется кнопка "скачать" в панели инструментов и качается версия и автоматически заменяются старые файлы на новые. было бы круто, ящитаю. 

    29. матриц генератор, задаваемый тремя векторами, одним достаточно, другие ортогонально угадываются, длина вектора - масщтаб, положение вектора в пространстве - поворот.

    надо думать 30. Обновление сокетов - применить везде дефиницию апдейт из утилов. Для этого изменить структуру передаваемых данных. нужно овладеть кэшем, кэш содержит данные каждого узла каждого сокета. передаётся только имя и фамилия узла через сокеты. Вопрос, как грамотно выстроить дерево обновления всех узлов, чтобы с начала до конца они ишли. иерархия, которая записывается в список? например [сок1, сок10, сок3, сок5, сок2] и в итоге пройдя по сокетам он обновит, но как составить список? На основании иерархии, а как иерархию учесть все уровни. Если несколько веток снова сростаются, например, выйдя из одного узла. или делать несколько списков, пока в списках не будет одинакового имени, и разделить списки до этого имени и после него и соединить между собой, а затем прибавить общий узел и дальше решать, но если есть разветвление любое, то его надо тоже в список как-то запихувать. то есть сначала до разветвления/общего_узла. Похоже что такова логика. при том, есть хаотичный список, перечень всех узлов с сокетами. Линейка в промежуточный список выстраивается по совпадениям имён узлов и сокетов. Так уже три списка, первый - просто перечень, второй - совпадения и фрагменты, третий - попытка соединить всё в одну линию с учётом всех развилок и схождений. как-то так. Обновление всех узлов должно зависеть от того, находятся ли узлы в связке с viewer draw или viewer text. Это важно.

    33. генератор сплайнов

    34. нахождение точки на сплайне

    35. узел вычитания и сложения серии векторов, чтобы получать из точки А и точки Б вектор АБ или БА, в зависимости от того, что от чего отнимать.

    36. Множитель вершин по матрицам, чтобы снять с вьювера монополию.

    37. Подумать над кэшем передачи данных. Данные передаются как имя узла и имя текущего дерева узлов. Затем, надо тут же предусмотреть некий центр обновления всего дерева. Спросить у Лукаса Тоена о том, как он решает обновление дерева. Если через кэш, то нужен центр управления, который следит за порядком подключения узлов, а значит отслеживает имя узла, имя узла на входе и так каждый узел, зате5м составляет динамическое дерево и проходя по нему насквозь с начала до конца обновляет все узлы... Как? Это целый комплекс, но работать должно опять же от кнопки апдейт или при каждом "шорохе" делать обновление? Скорее при каждом шорохе обновлять данные отдельных узлов (имена), но не всё дерево, а при нажатии кнопки "обновить" уже обновляет данные из узлов в кэше данных, который суть словарь. Это касается версии 0,3,0, надо будет такую ревизию провести. И обсудить ещё несколько раз.
    
    38. Вместе с тем, надо добавить тип сокета - кривые. Кривая определяется не так как линия, а двумя рычагами и узлом, итого три вектора на точку. Можно сделать кривую как линию, затем сконвертировать и сгладить, автоматически выстроив красивенько. И так и будет генерироваться кривая из векторов. Но как передавать значения? Если мы считаем формулами эту безье, то нам нужны специфические библиотеки, и их надо достать, ибо АПИ не имеет нужных инструментов (нахождение точки на кривой... это проблема, каждый разработчик решает по-своему), и также надо уметь замыкать кривые, а от этого меняется геометрия и нахождение точки на кривой и прочее. Рёбра уже не действуют на кривые, рёбра сокет может быть испольован именно для булена - зациклить или нет. В прочем, если мы все данные переводим в кэш, то можно использовать вектор сокет, оставив тем самым гибкость пользователю. и маркировать в кэше тип данных. Это всё касается версии 0,4,0. 

    39. узел-очиститель списка от нулевых данных, которые получаются при рассечении предварительно рассечённого объекта, так треугольники бывают не замкнутыми или вершины не найдеными, в общем, бывает.
    
    40. остались несколько узлов работы со списками, узел формула 2  и узел деформации матрицы требует дополнительного описания в уроках, это надо сделать.
    
    41. Текстовой просмотрщик при нажатии очищает кэш и кэш не привязан к узлу, не порядок.

    42. Ни центры полигонов ни адаптивные полигоны не работают с более чем одним объектом, это надо менять.

    43. Extrude для выдавливания вход - векторы, полигоны/рёбра, вектор(ы) выдавливания

    44. Объединитель объектов, который бы переназначал индексы вершин для полигонов. чтобы не с нуля, а по порядку.

    45. Просмотрщику установить галочку - активен/неактивен

    46. File input, csv data or something to be able to use external data.
 
    47. Boolean logic functions: and or xor, < > <= >= == != not

    48. Subdivide and produce useful topology Topology is main feature. needed node that takes vertex items, that belong to exact polygon

    49. Spin, (actually, just make change order of of generataded topology in cylinder would make it easy to spin object around axis. instead of bottom circle->top circle, see it more as a cyclic plane )

    50  Shear transformation matrix  

    51 вывод узла длины списка можно дать пользователю галочку для вывода списка в уровне 3 или в указанном уровне, в котором просчитывалось.

    52 подискутировать на тему уровня чисел, в вершинах, рёбрах и матрицах целые/дробные числа на 3 уровне, а в серии, случайном числе, в целом числе, они на 2 уровне. и вывод узла подсчёта площади и других на 2 уровне. преимущество - разделение по типам данных (где мы можем это применить?), но минус в разнобое. Люди теряются с уровнями.

    53 переназвать некоорые узлы, перенести лист бум в модификаторы  полигон бумом назвать, moth переименовать в math, лист левелс в лист декриз или list remove level

    54 доработать маску списков чтобы работала с многими объектами, сейчас все объекты маскируются по списку буленовых величин первого объекта в маске, объекты должны соответствовать.

    55 доделать наконец линий соединение.

    56 заделать систему поиска ошибок (валялась где-то)

    57 сделать автозапекатель, то есть узел, который бы держал на себе имена объектов, автоматически обновлял их геометрию, и удалял или создавал, если данные в сверчке меняются
    
    58 топология цилиндра. и вообще. пользователю дать шанс выбирать направление индексации полигонов/рёбер, UV

    59 разработать адаптивный сокет (он есть в узле маски). поместить его в утилы. Или подумать об отдельном сокете. Я предпочитаю утилы. Переубедите меня, если это не разумно (никита)

    60 colors in viewer draw
    61 transparancy
    62 lighting of faces
    63 text in 3d
    64 vectors as arrows

    65 shift to deal with levels
    66 3d cube generator
    67 object in - apply modifyer
    68 text in text out

    69 новые версии должны быть сдвинуты, мы не успеваем вложиться в 0,3,0, значит надо назначать вехи. много работы, а версий мало. 0,5,0 или даже больше - внедрение сплайнов. просто сдвигаются индексы.
    
    70 в утилиты вынести мультисокет и адаптивный сокет

    71 Все новые классы, которые подпадают в подклассы блендера должны именоваться начиная с префикса Sv_, так мы распознаем своих и исправить существующие классы с префиксом

    72 Сделать текстовый ввод, то есть узел, читающий из текстового файла координаты.
 
    73 сделать иерархию папок - чтобы модификаторы в одной папке были, генераторы в другой и т.д. и позасовывать всё, пока это не превратилось в ночной кашмар, и не забыть про пункт 30 - горит уже вчера надо было сделать, ведь каждый узел прийдётся переписывать.

    73 list item дописать, чтобы работал с списком индексов, чтобы выводил в адаптивный сокет, который надо дописать, см. пункт 70

    74 сокет материалов.

    75 узел группирования по маске. Вот есть предмет, шар. нам надо UV поменять. что для этого сделать - flip list, но флипать надо между уровнями групп вершин. а для этого их надо сгруппировать. То есть, если у нас U6,V12, то сгруппировать вершины по 6, затем флипнуть, так получим группы по 12, но всего групп 6,  было 12 групп по 6 вершин. То есть узел флип найдёт своего напарника "и они уйдут в закат"
